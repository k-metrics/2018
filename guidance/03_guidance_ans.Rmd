---
title: "第３回データ分析勉強会　演習解答例"
author: "鈴木さんぽう, CC BY-NC-SA 4.0"
date: "`r format(Sys.Date(), format = '%Y年%m月%d日')`"
output:
  html_document:
    css: style.css
    df_print: paged
    highlight: pygments
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)

require(tidyverse)
```


# 演習１　メトリクス統計分析入門から
メトリクス統計分析入門の演習1.4からの問題です。生産性に加えて、工数予実割合も加味してプロジェクトの評価をしようと考えています。以下の条件、方法に従い、各プロジェクトをA～Eの5段階で評価してください（詳細はテンプレート参照方）。

* データ分布の確認は省略してください（外れ値の判定も不要です）
* 分析手順はテンプレートに記載してあります
    * **欠損値があるレコード（プロジェクト）は外して**ください
* 分からない点は周りのメンバーと協力してチャレンジしてみてください
    * データの読み込みは[こちら](https://k-metrics.github.io/cabinet/import/index.html)にヒントがあります
    * [データファイル(CP932)](../data/data.csv), [データファイル(UTF8)](../data/data_utf8.csv)は（ローカル）リポジトリにあります

　  

## 解答例
```{r}
# データの読み込み(for Windows)
x <- "../data/data.csv" %>%
  read.csv() %>%
# データの読み込み(for Ubuntu)
# x <- "../data/data_utf8.csv" %>%
#   read.csv(encoding = "UTF-8") %>%
  dplyr::rename(pj = 'プロジェクト名', prod = '生産性', rate = '工数予実割合') %>% 
  tidyr::drop_na()

# 平均値と標準偏差の計算
y <- x %>% 
  dplyr::summarise_if(is.numeric, c("mean", "sd"), na.rm = TRUE)

# 評価換算のための基礎数値
breaks <- c(-Inf, -1.5, -0.5, 0.5, 1.5, Inf)
levels <- c("E", "D", "C", "B", "A")            # 因子の順番に注意

# Zスコアと偏差値、ランクの計算
x %>% 
  dplyr::mutate(prod_z = as.vector(scale(prod, y$prod_mean, y$prod_sd)),
                rate_z = as.vector(-scale(rate, y$rate_mean, y$rate_sd)),
                z = (prod_z + rate_z)/2,
                ss = z*10 + 50,
                rank = cut(z, breaks = breaks, labels = levels)) %>% 
  dplyr::mutate(prod_z = round(prod_z, 2), rate_z = round(rate_z, 2),
                z = round(z, 2), ss = round(ss)) %>% 
  dplyr::rename('プロジェクト' = pj, '生産性' = prod, '工数予実割合' = rate,
                '生産性Z値' = prod_z, '工数予実割合Z値' = rate_z,
                'Zスコア' = z, '偏差値' = ss, '評価' = rank)
```

　  

# 演習２　anscombeのデータ例
**`anscombe`**のデータ例を整然データに変換してください。 

　  

## 解答例
```{r}
anscombe %>%
  tibble::rownames_to_column("id") %>%
  tidyr::gather(key, value, -id) %>%
  tidyr::separate(key, c("axis", "group"), 1) %>%
  tidyr::spread(axis, value) %>% 
  dplyr::select(-id) %>% 
  dplyr::arrange(group)
```

　  

# 演習３　データフレームを変換する
`iris`データセットを以下のような形に変換してください。変換後の行数に注意してください。  

　  

## 解答例
```{r}
petal <- iris %>% 
  dplyr::select(Petal.Length, Petal.Width, Species) %>% 
  tidyr::gather(key = Petal, value = Petal.value, -Species) %>% 
  tibble::rowid_to_column("ID")

sepal <- iris %>% 
  dplyr::select(Sepal.Length, Sepal.Width, Species) %>% 
  tidyr::gather(key = Sepal, value = Sepal.value, -Species) %>% 
  tibble::rowid_to_column("ID")

(petal %>% 
  dplyr::left_join(sepal, by = c("ID", "Species")) %>% 
  dplyr::select(-ID))
```

　  

# 演習４　統計量のクロス集計
`mtcars`データセットを用いて`gear`（ギア数）と`cyl`（シリンダ数）で`mpg`（燃費）の平均値をクロス集計してください。

　  

## 解答例
```{r}
mtcars %>% 
  dplyr::select(mpg, cyl, gear) %>% 
  dplyr::group_by(cyl, gear) %>% 
  dplyr::summarise_all(mean, na.rm = TRUE) %>% 
  tidyr::spread(key = cyl, value = mpg)
```

　  

# 演習５　チケット数をカウントする
オープン・クローズチャートを作成するために2017年に起票されたRedmineのチケットを週単位でオープンチケットとクローズチケットに分けて集計してください。チケットデータは"data"フォルダ内にあります。    
　  
集計条件

* 2017年に起票されたチケット（開始日が2017/1/1から2017/12/31）が対象
* 集計は週次（2017年の第1週から第53週）
* オープンチケットは開始日で、クローズチケットは終了日で集計  
* 累計も計算する
* データがない週も考慮する

変数名は日本語ですが英語に変更しておいた方が処理の記述が楽です。

　  

## 解答例
```{r}
redmine <- "../data/redmine_data_utf8.csv" %>% 
  readr::read_csv() %>% 
  dplyr::select(ID = '#', status = 'ステータス', open = '作成日',
                close = '終了日') %>% 
  dplyr::mutate(open = lubridate::as_date(open),
                close = lubridate::as_date(close))

# Open
open <- redmine %>% 
  dplyr::filter(open >= "2017-1-1" & open <= "2017-12-31") %>% 
  dplyr::mutate(week = lubridate::week(open)) %>% 
  dplyr::group_by(week) %>% 
  dplyr::summarise(open = n())

# Closed
close <- redmine %>% 
  dplyr::filter(open >= "2017-1-1" & open <= "2017-12-31") %>% 
  dplyr::filter(close >= "2017-1-1" & close <= "2017-12-31") %>% 
  dplyr::mutate(week = lubridate::week(close),
                status_flag = ifelse(status == "Closed", "closed", "open")) %>% 
  dplyr::mutate(flag = ifelse(status_flag == "closed", 1, 0)) %>% 
  dplyr::group_by(week) %>% 
  dplyr::summarise(close = sum(flag))

# 週次の集計
data.frame(week = seq(1:53)) %>% 
  dplyr::left_join(open, by = "week") %>% 
  dplyr::left_join(close, by = "week") %>% 
  dplyr::mutate(open = tidyr::replace_na(open, 0),
                close = tidyr::replace_na(close, 0)) %>% 
  dplyr::mutate(cumopen = cumsum(open), cumclose = cumsum(close)) %>% 
  dplyr::select('週' = week, 'オープン数' = open, 'オープン数累計' = cumopen,
                'クローズ数' = close, 'クローズ数累計' = cumclose)
```

　  

# 演習６　クロス集計から比率を計算する
`ggplot2::mpg`データセットを`class`と`trans`でクロス集計し、**`class`ごと**に`trans`の比率を求めてください。

　  

## 解答例
```{r}
ggplot2::mpg %>% 
  dplyr::count(class, trans) %>% 
  tidyr::spread(key = class, value = n) %>%
  tidyr::gather(key, value, -trans) %>%
  dplyr::mutate(value = tidyr::replace_na(value, replace = 0L)) %>% 
  tidyr::spread(key, value) %>% 
  dplyr::mutate_if(is.numeric, prop.table) %>% 
  tidyr::gather(key, value, -trans) %>% 
  dplyr::mutate(value = dplyr::if_else(value == 0, NA_real_, round(value, 2))) %>% 
  tidyr::spread(key, value) %>% 
  as.data.frame() %>% 
  tibble::column_to_rownames("trans")
```

　  

# 演習７　メトリクス統計分析入門から
演習１において**欠損値があるレコード（行）を削除せず**にプロジェクトを評価してください。Zスコアは生産性のZスコアと工数予実割合のZスコアの平均値としますが、欠損値がある場合は片方のZスコアの値とします。  
　  

## 解答例
```{r}
# データの読み込み(for Windows)
x <- "../data/data.csv" %>%
  read.csv() %>%
# データの読み込み(for Ubuntu)
# x <- "../data/data_utf8.csv" %>%
#   read.csv(encoding = "UTF-8") %>%
  dplyr::rename(pj = 'プロジェクト名', prod = '生産性', rate = '工数予実割合')

# 平均値と標準偏差の計算
y <- x %>% 
  dplyr::summarise_if(is.numeric, c("mean", "sd"), na.rm = TRUE)

# 評価換算のための基礎数値
breaks <- c(-Inf, -1.5, -0.5, 0.5, 1.5, Inf)
levels <- c("E", "D", "C", "B", "A")            # 因子の順番に注意

# Zスコアと偏差値、ランクの計算
x %>% 
  dplyr::mutate(prod_z = as.vector(scale(prod, y$prod_mean, y$prod_sd)),
                rate_z = as.vector(-scale(rate, y$rate_mean, y$rate_sd)),
                z = ifelse(is.na(prod_z), rate_z, (prod_z + rate_z)/2),
                z = ifelse(is.na(rate_z), prod_z, (prod_z + rate_z)/2),
                ss = z*10 + 50,
                rank = cut(z, breaks = breaks, labels = levels)) %>% 
  dplyr::mutate(prod_z = round(prod_z, 2), rate_z = round(rate_z, 2),
                z = round(z, 2), ss = round(ss)) %>% 
  dplyr::rename('プロジェクト' = pj, '生産性' = prod, '工数予実割合' = rate,
                '生産性Z値' = prod_z, '工数予実割合Z値' = rate_z,
                'Zスコア' = z, '偏差値' = ss, '評価' = rank)
```

　  

# 演習８　複数の返り値がある場合
`iris`データセットを用いて以下のように品種、弁毎に四分位値を計算してください（ググればコードは分かると思いますが、かなりの難問。だけど覚えると便利）。

　  

## 解答例
```{r}
iris %>% 
  tidyr::gather(part, value, -Species) %>% 
  dplyr::group_by(Species, part) %>% 
  dplyr::do(qt = quantile(.$value)) %>%
  cbind(do.call(rbind, .$qt)) %>%
  dplyr::select(-qt)
```

　  

# 演習９　より複雑な返り値（リスト型）の場合
`iris`データセットを用いて回帰モデル（`Sepal.Length ~ Sepal.Width`）を層別に求めてみましょう。回帰モデルの返り値は四分位値よりも複雑なので要約には`broom`パッケージを用います。

　  

## 解答例
```{r}
iris %>% 
  dplyr::group_by(Species) %>% 
  dplyr::do(lm_res = lm(Sepal.Length ~ Sepal.Width, data = .)) %>% 
# coefficientsを表示する場合
  broom::tidy(lm_res)
# 計算値、残差などを表示する場合
#  broom::augment(lm_res)
# モデル評価値などを表示する場合
#  broom::glance(lm_re)
```

　  

# 演習１０　`purrr`を使ってみる
演習９を`purrr`パッケージを用いて解いてみましょう。`purrr`パッケージの使い方はググってみましょう （`dplyr::do`関数は将来的に廃止される可能性があるらしいので参考問題です）。  
　  
余談：「超難問」の超の使い方はあっている？  
　　　可能性は「高い低い」、「大きい小さい」、「あるない」？

　  

## 解答例
```{r, echo=FALSE}
# purrrを使う場合
require(purrr)
iris %>%
  split(.$Species) %>%
# リストの因子（Species）水準毎に処理をしデータフレームにまとめる
  purrr::map_dfr(~ lm(Sepal.Length ~ Sepal.Width, data = .) %>% broom::tidy(),
                 .id = "Species")
```

　  

## License
CC BY-NC-SA 4.0, Sampo Suzuki