---
title: "第２回データ分析勉強会"
author: "【午後の部】データハンドリング入門 [鈴木さんぽう, CC BY-NC-SA 4.0]"
date: "`r format(Sys.Date(), format = '%Y年%m月%d日')`"
output:
  ioslides_presentation:
    css: style.css
    df_print: paged
    logo: fig/hex-tidyverse.png
    smaller: false
    widescreen: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)

require(tidyverse)
```


## 本日の内容
1. リカバリータイム（午前）
1. 自己紹介（午前）
1. **データハンドリング入門（午後）**
    * 整然データ（tidy data）とは？
    * tidyverseとは？
    * パイプ演算子（` %>% `）
    * dplyr, tidyr, tibble
    * データハンドリング
1. 演習1～3


# データハンドリング入門

## メモを取るにもR markdown/RStudio
* メモを取りながら聞きたい、試しながら聞きたい場合はR Markdownファイルが便利です
    * ［File］-［New File］-［R Markdown...］-［Document］-［HTML］で新規作成
* キーボードショートカット
    * コードチャンクの挿入：［Ctrl］+［Shift］+［I］（アイ）
    * パイプ演算子の挿入：［Ctrl］+［Shift］+［M］
    * 代入演算子の挿入：［Alt］+［-］（マイナス）
    * 選択行のコードを実行する：［Ctrl］+［Enter］
    * コードを補完する：［Tab］
    * 選択している関数のヘルプ：［F1］

    
## 整然データとは？
* **整然データ**（tidy data）とはデータハンドリングを習得する上で**知っておくべき概念**
    * 一言で表すと「（Coddの）第三正規形」
    * [整然データとは何か (Colorless Green Ideas)](http://id.fnshr.info/2017/01/09/tidy-data-intro/)
    * [整然データってなに？ (Speaker Deck)](https://speakerdeck.com/fnshr/zheng-ran-detatutenani)
    * 整然データが理解できればデータハンドリングは理解できたようなもの

　  

* Rで最も使うデータ・フレーム型は整然データにしておくべき
    * ただし、人間が見ると分かりにくい面もある
    * 人間が分かりやすい（記録しやすい）雑然データへの変換は簡単


## tidyverseとは？
* The tidyverse is an opinionated collection of R packages designed for data science.
    * ggplot2, dplyr, tidyr,tibbleなどのパッケージ群を取りまとめているパッケージ
    * tidyなアーキテクチャに基づいたパッケージ群
        * パイプ演算子による処理を前提とした引数設計
    
```{r, comment=""}
tidyverse::tidyverse_packages()
```


## パイプ演算子（`%>%`）
パイプ演算子は`magrittr`パッケージで定義されている**左辺を右辺（の関数の第一引数）へ渡す**演算子です（`pipeR`パッケージのパイプ演算子とは別です）。
```{r, eval=FALSE}
summary(iris)
```
はパイプ演算子を用いると
```{r, eval=FALSE}
iris %>% summary()
```
と書くことができます。数珠つなぎにして複数の計算を分かりやすく記述できます。
```{r, eval=FALSE}
iris %>% 
  dplyr::filter(Species != "setosa") %>% 
  dplyr::group_by(Species) %>% 
  dplyr::summarise_if(is.numeric, funs(mean), na.rm = TRUE)
```


## パイプ演算子（`%>%`）を使わないと
先ほどの例をパイプ演算子を使わないで記述すると以下のようになります。
```{r, eval=FALSE}
  dplyr::summarise_if(
    dplyr::group_by(
      dplyr::filter(iris, Species != "setosa"), Species
    ), is.numeric, funs(mean), na.rm = TRUE
  )
```
中間変数を用いると以下のようになります。
```{r, eval=FALSE}
tmp1 <- dplyr::filter(iris, Species != "setosa")
tmp2 <- dplyr::group_by(tmp1, Species)
dplyr::summarise_if(tmp2, is.numeric, funs(mean), na.rm = TRUE)
```
この例からわかるようにパイプ演算子を用いることで分かりやすく修正しやすいコードが記述できることがわかると思います。


## dplyr
`dplyr`パッケージは整然データを効率的に扱う関数がまとめられた追加パッケージで以下のような関数が用意されています。

* 抽出・選択 : `sample_n`, `sample_frac`, `select`, `filter`, `distinct`
* 要約・集計 : `summarise`, `summarize`, `summarise_if`, `count`, `group_by`
* 追加・結合 : `mutate`, `mutate_if`, `left_join`, `full_join`, `bind_rows`

```{r}
iris %>% dplyr::sample_n(3)
```


## tidyr
`tidyr`パッケージはデータ構造を操作するための関数がまとめられた追加パッケージで以下のような関数が用意されています。

* 変形 : `gather`, `spread`
* 分離 : `separate`

```{r}
iris %>% 
  tidyr::gather(key, value, -Species) %>% 
  head(3)
```


## tibble
`tibble`パッケージはデータフレームをより使いやすくするための関数がまとめられた追加パッケージです。

* 便利 : `rowid_to_column`, `rownames_to_column`, `column_to_rownames`

```{r}
iris %>% 
  tibble::rowid_to_column("id") %>% 
  head(3)
```


## データハンドリング
* [dplyrのすゝめ](https://k-metrics.github.io/cabinet/program/basics_dplyr.html)
    * [dplyr](https://heavywatal.github.io/rstats/dplyr.html)
    * [tidyr](https://heavywatal.github.io/rstats/tidyr.html)
    * [readr](https://heavywatal.github.io/rstats/readr.html)

* 更に知りたい人のために
    * [tidyverse](https://www.tidyverse.org/)
    * [dplyr, part of tidyverse](http://dplyr.tidyverse.org/index.html)
    * [俺たちのtidyverseはこれからだ！](http://notchained.hatenablog.com/entry/tidyverse)


## 本日の内容
1. リカバリータイム（午前）
1. 自己紹介（午前）
1. データハンドリング入門（午後）
1. **演習1～3**
    * 『ソフトウェアメトリクス統計分析入門』から
        * 中間変数を作成せずに計算する方法の基本的な形です
    * anscombe（アンスコム）のデータ例
        * 第3回の`ggplot2`で使えるような形式への変換です
    * 列の分割
        * このような処理もよくあるパターンです

# 演習１

## メトリクス統計分析入門 演習1.4
生産性に加えて、工数予実割合も加味してプロジェクトの評価をしようと考えています。以下の条件、方法に従い、各プロジェクトをA～Eの5段階で評価してください。（詳細はテンプレート参照方）

* データ分布の確認は省略してください（外れ値の判定も不要です）
* 分析手順はテンプレートに記載してあります
    * **欠損値があるレコード（プロジェクト）は外して**ください
* 分からない点は周りのメンバーと協力してチャレンジしてみてください
    * データの読み込みは[こちら](https://k-metrics.github.io/cabinet/import/index.html)にヒントがあります
    * [データファイル(CP932)](../data/data.csv), [データファイル(UTF8)](../data/data_utf8.csv)は（ローカル）リポジトリにあります

## ヒント
やりたいこと       | 利用する関数例              | 備考
-------------------|-----------------------------|---
平均値を求めたい   | **`mean()`**                | 
標準偏差を求めたい | **`sd()`**                  | 
Zスコアを求めたい  | **`scale()`**               | 符号に注意
ランク分けしたい   | **`cut()`**                 | 無限大は`-Inf`, `Inf`
数値を丸めたい     | **`round()`**               |
NAを取り除きたい   | **`tidyr::drop_na()`**      | 
変数を要約したい   | **`dplyr::summarise_if()`** | 条件付きの変数要約
変数を追加したい   | **`dplyr::mutate()`**       | 


# 解答例

## 演習1.4 解答例
```{r echo=FALSE}
require(tidyverse)

# データの読み込み
x <- "../data/data.csv" %>%
  read.csv() %>%
# x <- "../data/data_utf8.csv" %>%
  # read.csv(encoding = "UTF-8") %>%
  dplyr::rename(pj = 'プロジェクト名', prod = '生産性', rate = '工数予実割合') %>% 
  tidyr::drop_na()

# 平均値と標準偏差の計算
y <- x %>% 
  dplyr::summarise_if(is.numeric, c("mean", "sd"), na.rm = TRUE)

# 評価換算のための基礎数値
breaks <- c(-Inf, -1.5, -0.5, 0.5, 1.5, Inf)
levels <- c("E", "D", "C", "B", "A")            # 因子の順番に注意

# Zスコアと偏差値、ランクの計算
x %>% 
  dplyr::mutate(prod_z = as.vector(scale(prod, y$prod_mean, y$prod_sd)),
                rate_z = as.vector(-scale(rate, y$rate_mean, y$rate_sd)),
                z = (prod_z + rate_z)/2,
                ss = z*10 + 50,
                rank = cut(z, breaks = breaks, labels = levels)) %>% 
  dplyr::mutate(prod_z = round(prod_z, 2), rate_z = round(rate_z, 2),
                z = round(z, 2), ss = round(ss)) %>% 
  dplyr::rename(`プロジェクト` = pj, `生産性` = prod, `工数予実割合` = rate,
                `生産性Z値` = prod_z, `工数予実割合Z値` = rate_z,
                `Zスコア` = z, `偏差値` = ss, `評価` = rank) %>%
  head(7) %>% knitr::kable()
```


# 演習２

## アンスコムのデータ例
```{r}
anscombe
```


## 整然データに変換する
先程の**`anscombe`**データセットを以下のような整然データに変換しなさい。  
　  
```{r, echo=FALSE}
anscombe %>%
  tibble::rownames_to_column("id") %>%
  tidyr::gather(key, value, -id) %>%
  tidyr::separate(key, c("axis", "group"), 1) %>%
  tidyr::spread(axis, value) %>% 
  dplyr::select(-id)
```


## ヒント
やりたいこと           | 利用する関数例                     | 備考
-----------------------|------------------------------------|---
列をまとめる           | **`tidyr::gather()`**              | 
行を列にする           | **`tidyr::spread()`**              | 
列名を分割する         | **`tidyr::separete()`**            |
ユニーク番号を付与する | **`tibble::rownames_to_cloumn()`** | 
列を選択する           | **`dplyr::select()`**              |


# 演習３

## 列を分割する
**`ggplot2::mpg`**データセットの**`trans`**から**`()`**で囲まれている部分を抜き出して**`trans_type`**と**`gear`**に分割しなさい。  
　  
```{r, echo=FALSE}
ggplot2::mpg %>% head(3)
```

　  
```{r, warning=FALSE, echo=FALSE}
ggplot2::mpg %>% 
  tidyr::separate(trans, into = c("trans_type", "gear"), sep = "[:punct:]") %>% 
  head(3)
```


## License
CC BY-NC-SA 4.0, Sampo Suzuki