---
title: "第６回データ分析勉強会"
author: "【午前の部】Redmineから自動的にチケットデータを取得しよう"
date: "`r format(Sys.Date(), format = '%Y年%m月%d日')`"
output:
  ioslides_presentation:
    css: style_img.css
    df_print: paged
    highlight: pygments
    # logo: fig/hex-rmarkdown.png
    smaller: false
    widescreen: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)

# require(shiny)      # shinyは使う必要はないと思われ
# require(ggplot2)    # ggplot2はtidyverseから呼び出される
require(redmineR)
require(lubridate)    # 日時を扱うパッケージ(tidyverseシリーズ)
require(tidyverse)    # tidyverseは最後に呼び出す方がコンフリクトの影響小
```


## 本日の内容
1. はじめに
1. RedmineからAPI経由でチケットデータを取得する。
1. チケットデータを整形する。
1. データを可視化する。
1. OpenCloseチャートを描く。
1. Dashboardを作ってみる。（時間があれば）

# はじめに

## CSV出力 -> 可視化じゃだめなの？

CSV出力だと**みんな**が**リアルタイム**で見れない。

## 目指す場所

メトリクスだけ見てても、開発の実態を知らないと気づけないことが多い。

**開発者自身が**メトリクスを見て、**改善**を図るようにできると最強。

そのため、**だれでも** **最新の**データが見れるようにしておくことが大切。

自動的にRedmineからチケットデータを取得して、(なるべく)リアルタイムに表示する。

## データ取得の方法

今回はRedmineのREST API経由でチケットデータを取得します。

RedmineのバックエンドにいるDB(MySQL,PostgreSQL,SQLite)に直接アクセスできるなら、
DB直アクセスが一番おすすめです。

* 取れないデータがない（REST APIからだと、Plug-inの拡張フィールドが取れなかったりする。）
* 更新分だけを取得できる（updated_onでフィルタ）

でも、大体はRedmineとDBは同じサーバ上に構築するので、
DB側の設定でlocahostから以外のアクセスができないようになっている。（デフォルト）

ということで、今回はとりあえずアカウントさえあればデータが取れるREST APIを使います。

# Redmineへアクセスしてみる。

## redmineRをインストールする。

`redmineR`インストールの前に、`remotes`というパッケージをインストールしておく必要があるらしい。

<!-- チャンクはRにしておくとコードハイライトが有効になる -->
```{r, eval=FALSE}
install.packages("remotes")
remotes::install_github("openanalytics/redmineR")
```

`redmineR`を読み込めればOK

```{r, eval=FALSE}
library(redmineR)
```

## Redmineの情報を入力する。

URLとAPIアクセストークンを環境変数に指定する。  
APIアクセストークンはRedmineにログインして、個人設定ページから入手する。  

```{r, eval=FALSE}
Sys.setenv("REDMINE_URL" = "http://xxx.xxx.xxx/xxx")
Sys.setenv("REDMINE_TOKEN" = "APIACCESSTOKEN")
```

<!-- こうすると実行はされるけどコードは表示されない -->
```{r, include=FALSE}
Sys.setenv("REDMINE_URL" = "https://www.redmine.org/")
Sys.setenv("REDMINE_TOKEN" = "APIACCESSTOKEN")
```

## プロジェクトの一覧
<!-- `redminer_df`クラスは何故かpaged表示をしてくれないので、表示の際はデータフレームに変換しておくと見やすい-->
```{r context="data", cache=FALSE}
redmineR::redmine_projects() %>% as.data.frame()
```

# チケットデータを取得して整形

## チケット一覧を取得する。

`redmine_issues`でチケット一覧を取得する。  
デフォルトだとクローズしたチケットを取得して来れない。  
全てのステータスのチケットを取得するためには`status_id = "*"`を指定する。

```{r load-data, context="data", cache=TRUE}
# issues <- redmine_issues(status_id = "*")
# issues <- redmine_issues()    # テスト用にcloseを除く
# save(issues, file = "../data/_redmine_issues_all.RData")
```

## デフォルトのチケット一覧を表示する。

リストから選ぶ系のフィールドが`<list [2]>`になってしまっている。

```{r echo=FALSE}
issues %>% as.data.frame()
```


## データ型を見てみる

```{r}
sapply(issues,class)
```


## mutateを使ったけどうまく行かなかった。

```{r}
# リスト型変数にNAが含まれていても展開するための関数（）
map_if_chr <- function(.x, .f) {
  purrr::map_if(.x, !is.na(.x), .f) %>% 
    purrr::map_chr(1L) %>% 
    return()
}

# テスト用
issues %>% 
  # dplyr::sample_n(100) %>%   # テスト用に１００件に絞る
  # custom_fieldsとparentが上手く展開できない...
  dplyr::select(-custom_fields, -parent) %>% 
  dplyr::mutate(
    pjid = purrr::map_int(project, 'id'),     # 一種のキーなのでNAはありえない
    project = map_if_chr(project, 'name'),
    tracker = map_if_chr(tracker, 'name'),
    status = map_if_chr(status, 'name'),
    priority = map_if_chr(priority, 'name'),
    author = map_if_chr(author, 'name'),
    assigned_to = map_if_chr(assigned_to, 'name'),
    category = map_if_chr(category, 'name'),
    created_on = lubridate::ymd_hms(created_on, tz = "UTC"),
    updated_on = lubridate::ymd_hms(updated_on, tz = "UTC"),
    closed_on = lubridate::ymd_hms(closed_on, tz = "UTC"),
    # custom_fields = map_if_chr(custom_fields, 'name'),
    fixed_version = map_if_chr(fixed_version, 'name'),
    start_date = lubridate::as_date(start_date),
    due_date = lubridate::as_date(due_date)
    # parent = map_if_chr(parent, 'name')
  )
# %>% readr::write_excel_csv(., path = "../data/_redmine_issues_all.csv")
```


```
issues %>%
  dplyr::mutate(
    created_on = as.POSIXct(strptime(created_on, "%Y-%m-%dT%H:%M:%S", tz="UCT")),
    closed_on = as.POSIXct(strptime(closed_on, "%Y-%m-%dT%H:%M:%S", tz="UCT")),
    updated_on = as.POSIXct(strptime(updated_on, "%Y-%m-%dT%H:%M:%S", tz="UCT")),
    project = project["name"],
    tracker = tracker[[1]]$name,
    status = status[[1]]$name,
    priority = priority[[1]]$name,
    author = author[[1]]$name,
    category = if_else(is.na(category), "", category[[2]]$name)
    # fixed_version = fixed_version$name
    # assigned_to = assigned_to$name
    ) %>%
  dplyr::select(id, project, tracker, status, priority, author, category, subject, description, done_ratio, created_on, updated_on, closed_on, estimated_hours) -> df
```

## 仕方ないので、for文で頑張る。

次ページから詳細説明。

```{r}
df <- data.frame()
for (i in 1:nrow(issues)){
  df[i, "id"] <- issues[i, "id"]
  df[i, "project"] <- issues[i, "project"][[1]]$name
  df[i, "tracker"] <- issues[i, "tracker"][[1]]$name
  df[i, "status"] <- issues[i, "status"][[1]]$name
  df[i, "priority"] <- issues[i, "priority"][[1]]$name
  df[i, "author"] <- issues[i, "author"][[1]]$name
  df[i, "category"] <- ifelse(is.na(issues[i, "category"]), NA, issues[i, "category"][[1]]$name)
  df[i, "fixed_version"] <- ifelse(is.na(issues[i, "fixed_version"]), NA, issues[i, "fixed_version"][[1]]$name)
  df[i, "assigned_to"] <- ifelse(is.na(issues[i, "assigned_to"]), NA, issues[i, "assigned_to"][[1]]$name)
  df[i, "created_on"] <- as.POSIXct(strptime(issues[i, "created_on"], "%Y-%m-%dT%H:%M:%S", tz="UCT"))
  df[i, "updated_on"] <- as.POSIXct(strptime(issues[i, "updated_on"], "%Y-%m-%dT%H:%M:%S", tz="UCT"))
  df[i, "closed_on"] <- as.POSIXct(strptime(issues[i, "closed_on"], "%Y-%m-%dT%H:%M:%S", tz="UCT"))
}
```

## listの処理

`issues$project`の構造はこんな感じなっている。

```{r}
issues[1, "project"]
```

`list`の1番目に`id`と`name`が入っている。

```{r}
  df[i, "project"] <- issues[i, "project"][[1]]$name
```

## `NA`の処理

`NA`が入っているカラムは`ifelse`で`NA`じゃなかった場合のみ、
`list`の要素にアクセスするようにしないと、エラーになってしまう。

```{r}
  df[i, "category"] <- 
    ifelse(is.na(issues[i, "category"]), NA, issues[i, "category"][[1]]$name)
```

## 日付の処理

日付(created_on, closed_on, updated_on)は(残念ながら)文字列型。

```{r}
issues[1, "created_on"]
```

`as.POSIXct`を使って、日付型にする。

```{r}
  df[i, "created_on"] <-
    as.POSIXct(strptime(issues[i, "created_on"], "%Y-%m-%dT%H:%M:%S", tz="UCT"))
```

## これでオッケー？

```{r echo=FALSE}
df
```

## なんか日時がおかしい。。。

```{r}
df$created_on
```


## created_onなどをDate型に修正

`as.Date.POSIXct`で日付型に変換する。

```{r}
as.Date.POSIXct(1538719009)
```

`mutate`で1つずつ変換してもいいが、`mutate_at`を使えば、まとめて変換できる。

```{r}
df <- df %>% 
  dplyr::mutate_at(vars(created_on,updated_on,closed_on), as.Date.POSIXct)
```

## 日付が修正された

```{r echo=FALSE}
df
```


# 可視化する。

## 棒グラフ

```{r}
df %>% ggplot(aes(x = status)) +
  geom_bar() + theme_bw(base_family = "HiraKakuProN-W3")
```

## 円グラフ

```{r pie-chart-chunk}
df %>% ggplot(aes(x="", fill=tracker)) +
  geom_bar(width = 1) + coord_polar("y") + theme_bw(base_family = "HiraKakuProN-W3")
```


# Open/Closeチャートを描く。

## Openチャートを作る

```{r}
open <- df %>% 
  dplyr::group_by(created_on) %>% 
  dplyr::count() %>% 
  dplyr::rename(date = created_on,
                open = n)
open
```

## Closeチャートを作る

```{r}
close <- df %>% 
  dplyr::filter(status=="終了") %>% 
  dplyr::group_by(closed_on) %>% 
  dplyr::count() %>% 
  dplyr::rename(
    date = closed_on,
    close = n
  )
close
```


## openとcloseを結合

```{r}
max_date <- max(open$date, close$date)
min_date <- min(open$date, close$date)
openclose <- data.frame(date=seq(min_date, max_date, by = "day")) %>% 
  dplyr::left_join(open, by = "date") %>%
  dplyr::left_join(close, by = "date") %>% 
  replace_na(list(open=0, close=0))

openclose
```

## Open/Closeチャートを描く

```{r}
openclose$cumsum_open <- cumsum(openclose$open)
openclose$cumsum_close <- cumsum(openclose$close)
openclose
```

## Open/Closeチャートを描く

```{r}
openclose %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = cumsum_close, color = "cumsum_close")) +
  geom_line(aes(y = cumsum_open, color = "cumsum_open"))
```
