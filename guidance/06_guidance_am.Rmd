---
title: "第６回データ分析勉強会【午前】"
output: 
  html_document:
    # css: style.css
    code_folding: show
    df_print: paged
    highlight: "default"
    md_extensions: -ascii_identifiers
    number_section: yes
    theme: "default"
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: yes
      smooth_scroll: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)

require(redmineR)
require(tidyverse)    # tidyverseは最後に呼び出す方がコンフリクトの影響小
```

# Redmineへアクセスしてみる

## redmineRをインストールする

`redmineR`パッケージはGitHubからインストールするために`devtools`や`remotes`というパッケージを事前にインストールしておく必要があります。第1回勉強会にて環境構築した方は`devtools`パッケージがインストールされているハズですので、これを使います。  

<!-- チャンクはRにしておくとコードハイライトが有効になる -->
```{r, eval=FALSE}
devtools::install_github("openanalytics/redmineR")
```

`redmineR`を読み込めればOK
```{r, eval=FALSE}
library(redmineR)
```

あとは`tidyverse`を読み込む。`tidyverse`のうち使うのはこの3つ。

|パッケージ  |  説明              |
|------------|--------------------|
|`dplyr`     |データフレーム操作  |
|`lubridate` |日付操作            |
|`ggplot2`   |可視化              |

　  
`lubridate`パッケージは`tidyverse`ファミリーですが`tidyverse`パッケージを読み込んだだけでは読み込まれないないので、別途、明示的に読み込んでください。  

```{r, eval=FALSE}
library(lubridate)
library(tidyverse)    # tidyverseは最後に呼び出す方がコンフリクトの影響小
```

なお、追加パッケージを読み込んだ場合は、`tidyverse::tidyverse_conflicts`関数でコンフリクト状態を把握しておくと意図しない動きの場合の原因追及に使えるので便利です。  
```{r}
tidyverse::tidyverse_conflicts()
```

　  

## Redmineの情報を入力する

URLとAPIアクセストークンを環境変数に指定する。  
APIアクセストークンはRedmineにログインして、個人設定ページから入手する。  

```{r, eval=FALSE}
Sys.setenv("REDMINE_URL" = "http://xxx.xxx.xxx/xxx")
Sys.setenv("REDMINE_TOKEN" = "APIACCESSTOKEN")
```

<!-- こうすると実行はされるけどコードは表示されない -->
```{r, include=FALSE}
Sys.setenv("REDMINE_URL" = "https://www.redmine.org/")
Sys.setenv("REDMINE_TOKEN" = "APIACCESSTOKEN")
```

## 動作確認
プロジェクトの一覧取得とかが軽めのAPIでおすすめ。
<!-- `redminer_df`クラスは何故かpaged表示をしてくれないので、表示の際はデータフレームに変換しておくと見やすい-->
```{r context="data"}
redmineR::redmine_projects() %>% as.data.frame()
```

# チケットデータを取得する

## チケット一覧を取得する

`redmine_issues`でチケット一覧を取得する。  
デフォルトだとクローズしたチケットを取得して来れない。  
全てのステータスのチケットを取得するためには`status_id = "*"`を指定する。

```{r, eval=FALSE}
issues <- redmineR::redmine_issues(status_id = "*")
# save(issues, file = "../data/_redmine_issues_all.RData")
```
皆様はこちらをお使いください。サンプル用データロードします。
```{r}
# .RDataはGitHubのデフォルトではignore対象なので、".RData_"に変えてあります
load("../data/_redmine_issues_all.RData_")
# save(issues, file = "../data/_redmine_issues_all.RData")
```

## redmineRで取ってきたチケットを見てみる
[各フィールドの説明](https://k-metrics.netlify.com/post/2018-10/redminer/)

<!-- ここの説明はもう少し整理した方がよさそうです。例えば
　1.全体の俯瞰
　2.型（クラス）の確認
　3.NA有無の確認
　4.イレギュラーデータの確認
　5.型の変換やNAの処理-->

### まずは全体を俯瞰
```{r}
issues %>% head(100) %>% as.data.frame()
```
`<list [2]>`やら、`NA`やら、結構汚いデータなので、きれいにするところから始める。

### 型（クラス）の確認

```{r}
issues %>% 
  purrr::map_df(class)
```

projectやtrackerなど、リストから選ぶ系のフィールドが`list`型になってしまっている。`list(id="ID", name="NAME")`から`NAME`を取り出したい。
```{r}
issues$project[[1]]
```

日付、日時が文字列型になってしまっている。日付は`date`に、日時は`POSIXct`型に変換したい。
```{r}
issues %>% head(100) %>%
  dplyr::select(id, created_on, closed_on, updated_on, start_date, due_date) %>% 
  as_data_frame()
```

### `NA`有無の確認
厄介なのは、リスト型のカラムの中にある`NA`。
```{r}
# NAの有無確認
issues %>% 
  purrr::map_df(anyNA)
# 型の確認
issues %>% 
  purrr::map_df(class)
```

# データを整形する
<!-- 変換はmutate_atあたりでまとめた方がいいかも。list型でもparentだけは他の
リスト型とはデータの入り方が異なるので、mutate_ifで一括処理ができない-->
```{r}
# リスト型変数にNAが含まれていても展開するための関数（）
map_if_chr <- function(.x, .f) {
  purrr::map_if(.x, !is.na(.x), .f) %>% 
    purrr::map_chr(1L) %>% 
    return()
}

df <- issues %>% 
  # dplyr::sample_n(100) %>%   # テスト用に１００件に絞る
  # custom_fieldsが上手く展開できない...
  dplyr::select(-custom_fields) %>% 
  dplyr::mutate(
    pjid = purrr::map_int(project, 'id'),     # 一種のキーなのでNAはありえない
    project = map_if_chr(project, 'name'),
    tracker = map_if_chr(tracker, 'name'),
    status = map_if_chr(status, 'name'),
    priority = map_if_chr(priority, 'name'),
    author = map_if_chr(author, 'name'),
    assigned_to = map_if_chr(assigned_to, 'name'),
    category = map_if_chr(category, 'name'),
    created_on = lubridate::ymd_hms(created_on, tz = "UTC"),
    updated_on = lubridate::ymd_hms(updated_on, tz = "UTC"),
    closed_on = lubridate::ymd_hms(closed_on, tz = "UTC"),
    # custom_fields = map_if_chr(custom_fields, 'name'),
    fixed_version = map_if_chr(fixed_version, 'name'),
    start_date = lubridate::as_date(start_date),
    due_date = lubridate::as_date(due_date),
    parent = map_if_chr(parent, 'id')
  )
# データ数が多すぎてレンダリングに時間がかかりすぎるので先頭100行のみとする
head(df, 100)
# %>% readr::write_excel_csv(., path = "../data/_redmine_issues_all.csv")
```
以下、説明

## リスト型
リスト型変数は任意の型で任意の数のデータを任意な数だけ持てる柔軟性のあるデータ構造です。リスト型の中にリスト型をネストさせることも可能です。    
```{r}
list(list(id = c(1, 2)), list(name = c("Defects")))
```

## リスト型の処理
このようなリスト型変数を扱うには`purrr`パッケージ（part of tidyverse）が便利です。例えばチケットの`project`データは以下のような構成になっています。    
```{r}
issues %>% head(1) %>% dplyr::select(project) %>% purrr::flatten()
```
この中から`name`だけを取り出すには`purrr::map`関数群を用います。
```{r}
issues %>% head() %>% dplyr::select(project) %>% 
  dplyr::mutate(pjname_l = purrr::map(project, 'name'),
                pjname_v = purrr::map_chr(project, 'name'))
```
関数によって返り値が異なるので注意してください。

## `NA`の処理
`NA`が含まれる場合は`purrr::map_if`関数を用います。
```{r}
issues %>% dplyr::sample_n(100) %>% dplyr::select(assigned_to) %>% 
  dplyr::mutate(name_l = purrr::map_if(assigned_to, !is.na(assigned_to), 'name'),
                name_v = purrr::map_chr(purrr::map_if(assigned_to,
                                                      !is.na(assigned_to), 'name'),
                                        1L))
```

`NA`が入っているカラムは`ifelse`で`NA`じゃなかった場合のみ、
`list`の要素にアクセスするようにしないと、エラーになってしまう。

```{r error=TRUE}
  df[i, "category"] <- 
    ifelse(is.na(issues[i, "category"]), NA, issues[i, "category"][[1]]$name)
```

## created_onなどをDate型に修正
文字列を日付型に変換するには`lubridate`パッケージを使うと分かりやすい。
<!-- `as.Date.POSIXct`で日付型に変換する。 -->
日付の場合は、`as_date`
```{r}
lubridate::as_date("2018/10/05")
```

日時の場合は、`ymd_hms`
```{r}
lubridate::ymd_hms("2018-10-15T01:43:12Z", tz = "UTC")
```


# 可視化する。
<!-- ggplot2でフォントを指定しないと日本語が正しく表示されないのはMacOSのみ 
　　 なので、日本語フォントを指定する場合は、IPAフォントやNotoフォントの
　　 ようにOSに依存することなくフリーで使えるフォントを指定した方がベター
　　 IPAフォント： https://ipafont.ipa.go.jp/　（明朝, ゴシック）
　　 Notoフォント： https://www.google.com/get/noto/　（Serif, SansSerif, Mono）
　　 -->

## 棒グラフ

```{r}
#windowsFonts("MEI"=windowsFont("Meiryo"))
df %>% ggplot(aes(x = status)) +
  geom_bar() + theme_bw(base_family = "HiraKakuProN-W3")
```

## 円グラフ
```{r pie-chart-chunk}
df %>% ggplot(aes(x="", fill=tracker)) +
  geom_bar(width = 1) + coord_polar("y") + theme_bw(base_family = "HiraKakuProN-W3")
```


# Open/Closeチャートを描く

## Openチャートを作る

```{r}
open <- df %>% 
  mutate(
    created_on = lubridate::as_date(created_on)
  ) %>% 
  dplyr::group_by(created_on) %>% 
  dplyr::count() %>% 
  dplyr::rename(date = created_on,
                open = n)
open %>% head(100)
```

## Closeチャートを作る

```{r}
close <- df %>% 
  dplyr::filter(status=="Closed") %>% 
  dplyr::mutate(closed_on = lubridate::as_date(closed_on)) %>% 
  dplyr::group_by(closed_on) %>% 
  dplyr::count() %>% 
  dplyr::rename(
    date = closed_on,
    close = n
  )
close %>% head(100)
```


## openとcloseを結合

```{r}
max_date <- max(open$date, close$date)
min_date <- min(open$date, close$date)
openclose <- data.frame(date=seq(min_date, max_date, by = "day")) %>% 
  dplyr::left_join(open, by = "date") %>%
  dplyr::left_join(close, by = "date") %>% 
  replace_na(list(open=0, close=0))

openclose
```

## Open/Closeチャートを描く

```{r}
openclose$cumsum_open <- cumsum(openclose$open)
openclose$cumsum_close <- cumsum(openclose$close)
openclose %>% head(100)
```

## Open/Closeチャートを描く

```{r}
openclose %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = cumsum_close, color = "cumsum_close")) +
  geom_line(aes(y = cumsum_open, color = "cumsum_open"))
```

# カスタムフィールドの扱い（未完成）

## custom_fieldsの中身
```{r, echo=FALSE}
# 複数のcustom_fieldを持っている行を探しているだけ
for(i in 1:nrow(issues)){
  if(!is.na(issues[i,"custom_fields"])){
    counter <- 0
    for(custom_field in issues[i,"custom_fields"][[1]]){
      if(custom_field["value"]!=""){
        counter <- counter + 1
      }
    }
    if(counter > 1){
      tmp_custom_fields <- issues[i,"custom_fields"]
      break
    }
  }
}
```

```{r}
tmp_custom_fields
```

とっても複雑な構造。。。  
要するにこういうこと
```{r, eval=FALSE}
list(
  list(
    list(id=2, name="Resolution", value="Invalid"),
    list(id=4, name="Affected version", value=133)
  )
)
```

|フィールド|フィールドの説明|
|---|---|
|id    |カスタムフィールドID|
|name  |カスタムフィールド名|
|value |カスタムフィールドの値(※)|

※ プルダウンで選ぶ形式のカスタムフィールドの場合、
valueは各選択肢へのIDになっている。
実際の値を得るためには、バージョンやカスタムフィールドの情報を別途APIを叩いて入手するしかない。

以下が、カスタムフィールドの値取得に必要なAPIだが、
残念ながらredmineRでは取れない。
そのため、REST Client（`RCurl` or `httr`がメジャーらしい）を使って、
直接REST APIを叩くことになる。  
jsonの中身を分析するだけなので、頑張ればできる。

|フィールドの種類|API|必要な権限|
|---|---|---|
|version|[/projects/<project_id>/versions](http://www.redmine.org/projects/redmine/wiki/Rest_Versions)|普通でOK|
|list|[/custom_fields](http://www.redmine.org/projects/redmine/wiki/Rest_CustomFields)|管理者権限|

## カスタムフィールドをdata.frameに格納
mutateやpurrr使っても上手くいかなかった。  
そのため、for文でぶん回す。

```{r}
for(i in 1:nrow(df)){
  if(!is.na(issues[i,"custom_fields"])){
    for(custom_field in issues[i,"custom_fields"][[1]]){
      if(!is.null(custom_field$value)){
        df[i, custom_field$name] <- custom_field$value
      }
    }
  }
}
```

ResolutionとAffected versionが取れた。
```{r}
df %>% 
  dplyr::select("id", "Resolution", "Affected version")
```

Affected versionの値はversionのID。
実際にどのバージョンかを知るためには、version取得APIを叩いて、値を検索する。


## カスタムフィールルドの展開
`purrr`パッケージで処理する方法を模索中

### カスタムフィールドの確認
カスタムフィールドの中身を確認（または表示）したい場合は`knitr::kable`関数を用いると便利。
```{r}
issues %>% 
  head() %>% 
  dplyr::select(id, custom_fields) %>% 
  knitr::kable()
```

### カスタムフィールドの展開
リスト型変数がネストされているカスタムフィールドを展開するには、いったん、`list(list)`の状態を解消（アンネスト）して、展開後にNAになっているデータを削除する。  
その後、リスト型変数の展開処理を行う。
```{r}
# id毎に展開できるがリストが展開されたままなのでまとめたい
issues %>% 
  head() %>% 
  dplyr::select(id, custom_fields) %>% as.data.frame() %>% 
  tidyr::unnest() %>% knitr::kable()

map_if_chr <- function(.x, .f) {
  purrr::map_if(.x, !is.na(.x), .f) %>% 
    purrr::map_chr(1L) %>% 
    return()
}

# unnested_issues <- issues %>%
#   # head() %>%
#   dplyr::select(id, custom_fields) %>% as.data.frame() %>%
#   tidyr::unnest() %>% 
#   tidyr::drop_na() %>% as.data.frame() %>% 
#   tibble::rowid_to_column("rows")

# 以下で展開できるが、`value`項のないデータがあるためこれらを処理しようとすると
# エラーになる（揺れの処理が必要）
# id     値
# 16451  list(id = 4, name = "Affected version")
# 16447  list(id = 4, name = "Affected version")
# 16379　list(id = 4, name = "Affected version")
# 16357　list(id = 4, name = "Affected version")

# 上記のデータを除くと処理はできる
issues %>%
  head(100) %>%
  dplyr::select(id, custom_fields) %>% as.data.frame() %>%
  tidyr::unnest() %>% 
  tidyr::drop_na() %>% 
  dplyr::mutate(name = map_if_chr(custom_fields, 'name'),
                value = map_if_chr(custom_fields, 'value')) %>% 
  dplyr::select(-custom_fields) %>% 
  tidyr::spread(key = name, value = value) %>% 
  dplyr::left_join(issues, by = "id")

```


<!-- # list操作 -->
<!-- # http://delta0726.web.fc2.com/packages/data/00_purrr.html -->
<!-- # nested dataframe -->
<!-- # https://suryu.me/post/r_advent_calendar_day3/ -->
